<html>
<head>
<title>Mesa Source Code Documentation</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head>
<body>
<div class="qindex">
<a class="qindex" href="../main/index.html">core</a> |
<a class="qindex" href="../glapi/index.html">glapi</a> |
<a class="qindex" href="../glsl/index.html">glsl</a> |
<a class="qindex" href="../nir/index.html">nir</a> |
<a class="qindex" href="../vbo/index.html">vbo</a> |
<a class="qindex" href="../math/index.html">math</a> |
<a class="qindex" href="../swrast/index.html">swrast</a> |
<a class="qindex" href="../swrast_setup/index.html">swrast_setup</a> |
<a class="qindex" href="../tnl/index.html">tnl</a> |
<a class="qindex" href="../tnl_dd/index.html">tnl_dd</a> |
<a class="qindex" href="../gbm/index.html">gbm</a> |
<a class="qindex" href="../i965/index.html">i965</a>
</div>
<!-- Generated by Doxygen 1.8.12 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_f13bc85843fa14191e0ad4a3a157cf60.html">compiler</a></li><li class="navelem"><a class="el" href="dir_4172b1ff1383a72421e897c24b01e6f0.html">glsl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">blob.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structblob.html">blob</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structblob__reader.html">blob_reader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:adf49f24209b693e97e04e4e710da5e10"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="structblob.html">blob</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#adf49f24209b693e97e04e4e710da5e10">blob_create</a> (void)</td></tr>
<tr class="memdesc:adf49f24209b693e97e04e4e710da5e10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new, empty blob.  <a href="#adf49f24209b693e97e04e4e710da5e10">More...</a><br /></td></tr>
<tr class="separator:adf49f24209b693e97e04e4e710da5e10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0289d38b69eb83c4fa9542e76ac44e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy</a> (struct <a class="el" href="structblob.html">blob</a> *<a class="el" href="structblob.html">blob</a>)</td></tr>
<tr class="memdesc:a9d0289d38b69eb83c4fa9542e76ac44e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a blob and free its memory.  <a href="#a9d0289d38b69eb83c4fa9542e76ac44e">More...</a><br /></td></tr>
<tr class="separator:a9d0289d38b69eb83c4fa9542e76ac44e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a5ee8f5d7ef18a165291f2e90c61ef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#ad9a5ee8f5d7ef18a165291f2e90c61ef">blob_write_bytes</a> (struct <a class="el" href="structblob.html">blob</a> *<a class="el" href="structblob.html">blob</a>, const void *bytes, size_t to_write)</td></tr>
<tr class="memdesc:ad9a5ee8f5d7ef18a165291f2e90c61ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add some unstructured, fixed-size data to a blob.  <a href="#ad9a5ee8f5d7ef18a165291f2e90c61ef">More...</a><br /></td></tr>
<tr class="separator:ad9a5ee8f5d7ef18a165291f2e90c61ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a259e953346c51f72cc2f3c9632463dd7"><td class="memItemLeft" align="right" valign="top">uint8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a259e953346c51f72cc2f3c9632463dd7">blob_reserve_bytes</a> (struct <a class="el" href="structblob.html">blob</a> *<a class="el" href="structblob.html">blob</a>, size_t to_write)</td></tr>
<tr class="memdesc:a259e953346c51f72cc2f3c9632463dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reserve space in  for a number of bytes.  <a href="#a259e953346c51f72cc2f3c9632463dd7">More...</a><br /></td></tr>
<tr class="separator:a259e953346c51f72cc2f3c9632463dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab55011b62aa474bb6644a0dcb304af4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#ab55011b62aa474bb6644a0dcb304af4f">blob_overwrite_bytes</a> (struct <a class="el" href="structblob.html">blob</a> *<a class="el" href="structblob.html">blob</a>, size_t offset, const void *bytes, size_t to_write)</td></tr>
<tr class="memdesc:ab55011b62aa474bb6644a0dcb304af4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite some data previously written to the blob.  <a href="#ab55011b62aa474bb6644a0dcb304af4f">More...</a><br /></td></tr>
<tr class="separator:ab55011b62aa474bb6644a0dcb304af4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5637884a67186930463dce643a5a16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a7a5637884a67186930463dce643a5a16">blob_write_uint32</a> (struct <a class="el" href="structblob.html">blob</a> *<a class="el" href="structblob.html">blob</a>, uint32_t value)</td></tr>
<tr class="memdesc:a7a5637884a67186930463dce643a5a16"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uint32_t to a blob.  <a href="#a7a5637884a67186930463dce643a5a16">More...</a><br /></td></tr>
<tr class="separator:a7a5637884a67186930463dce643a5a16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1072776ca723a121a6e1a7483b751e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a4a1072776ca723a121a6e1a7483b751e">blob_overwrite_uint32</a> (struct <a class="el" href="structblob.html">blob</a> *<a class="el" href="structblob.html">blob</a>, size_t offset, uint32_t value)</td></tr>
<tr class="memdesc:a4a1072776ca723a121a6e1a7483b751e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overwrite a uint32_t previously written to the blob.  <a href="#a4a1072776ca723a121a6e1a7483b751e">More...</a><br /></td></tr>
<tr class="separator:a4a1072776ca723a121a6e1a7483b751e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3623542d5a2fa919b9cef4e63af89154"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a3623542d5a2fa919b9cef4e63af89154">blob_write_uint64</a> (struct <a class="el" href="structblob.html">blob</a> *<a class="el" href="structblob.html">blob</a>, uint64_t value)</td></tr>
<tr class="memdesc:a3623542d5a2fa919b9cef4e63af89154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a uint64_t to a blob.  <a href="#a3623542d5a2fa919b9cef4e63af89154">More...</a><br /></td></tr>
<tr class="separator:a3623542d5a2fa919b9cef4e63af89154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46f90857fbe6ad55b792ea2607410fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#ab46f90857fbe6ad55b792ea2607410fe">blob_write_intptr</a> (struct <a class="el" href="structblob.html">blob</a> *<a class="el" href="structblob.html">blob</a>, intptr_t value)</td></tr>
<tr class="memdesc:ab46f90857fbe6ad55b792ea2607410fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an intptr_t to a blob.  <a href="#ab46f90857fbe6ad55b792ea2607410fe">More...</a><br /></td></tr>
<tr class="separator:ab46f90857fbe6ad55b792ea2607410fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab096d8fb77c2c02ab782c53d6bd00940"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#ab096d8fb77c2c02ab782c53d6bd00940">blob_write_string</a> (struct <a class="el" href="structblob.html">blob</a> *<a class="el" href="structblob.html">blob</a>, const char *str)</td></tr>
<tr class="memdesc:ab096d8fb77c2c02ab782c53d6bd00940"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a NULL-terminated string to a blob, (including the NULL terminator).  <a href="#ab096d8fb77c2c02ab782c53d6bd00940">More...</a><br /></td></tr>
<tr class="separator:ab096d8fb77c2c02ab782c53d6bd00940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefb5f193f1f9cf1d2b5789e69b3d7f13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#aefb5f193f1f9cf1d2b5789e69b3d7f13">blob_reader_init</a> (struct <a class="el" href="structblob__reader.html">blob_reader</a> *<a class="el" href="structblob.html">blob</a>, uint8_t *data, size_t size)</td></tr>
<tr class="memdesc:aefb5f193f1f9cf1d2b5789e69b3d7f13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start reading a blob, (initializing the contents of  for reading).  <a href="#aefb5f193f1f9cf1d2b5789e69b3d7f13">More...</a><br /></td></tr>
<tr class="separator:aefb5f193f1f9cf1d2b5789e69b3d7f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9885922f129ad8afc10e24d306d79d75"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a9885922f129ad8afc10e24d306d79d75">blob_read_bytes</a> (struct <a class="el" href="structblob__reader.html">blob_reader</a> *<a class="el" href="structblob.html">blob</a>, size_t size)</td></tr>
<tr class="memdesc:a9885922f129ad8afc10e24d306d79d75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some unstructured, fixed-size data from the current location, (and update the current location to just past this data).  <a href="#a9885922f129ad8afc10e24d306d79d75">More...</a><br /></td></tr>
<tr class="separator:a9885922f129ad8afc10e24d306d79d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efddf61bdfca4f2ea76759f0bec9938"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a0efddf61bdfca4f2ea76759f0bec9938">blob_copy_bytes</a> (struct <a class="el" href="structblob__reader.html">blob_reader</a> *<a class="el" href="structblob.html">blob</a>, uint8_t *dest, size_t size)</td></tr>
<tr class="memdesc:a0efddf61bdfca4f2ea76759f0bec9938"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some unstructured, fixed-size data from the current location, copying it to  (and update the current location to just past this data)  <a href="#a0efddf61bdfca4f2ea76759f0bec9938">More...</a><br /></td></tr>
<tr class="separator:a0efddf61bdfca4f2ea76759f0bec9938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11dda238c6aff2f23a4a07272409868e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a11dda238c6aff2f23a4a07272409868e">blob_read_uint32</a> (struct <a class="el" href="structblob__reader.html">blob_reader</a> *<a class="el" href="structblob.html">blob</a>)</td></tr>
<tr class="memdesc:a11dda238c6aff2f23a4a07272409868e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a uint32_t from the current location, (and update the current location to just past this uint32_t).  <a href="#a11dda238c6aff2f23a4a07272409868e">More...</a><br /></td></tr>
<tr class="separator:a11dda238c6aff2f23a4a07272409868e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b8efff7117e040c74fb7df19d3dd0c9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a3b8efff7117e040c74fb7df19d3dd0c9">blob_read_uint64</a> (struct <a class="el" href="structblob__reader.html">blob_reader</a> *<a class="el" href="structblob.html">blob</a>)</td></tr>
<tr class="memdesc:a3b8efff7117e040c74fb7df19d3dd0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a uint64_t from the current location, (and update the current location to just past this uint64_t).  <a href="#a3b8efff7117e040c74fb7df19d3dd0c9">More...</a><br /></td></tr>
<tr class="separator:a3b8efff7117e040c74fb7df19d3dd0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c32b7278d13a86fccf1955d570f96e7"><td class="memItemLeft" align="right" valign="top">intptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a1c32b7278d13a86fccf1955d570f96e7">blob_read_intptr</a> (struct <a class="el" href="structblob__reader.html">blob_reader</a> *<a class="el" href="structblob.html">blob</a>)</td></tr>
<tr class="memdesc:a1c32b7278d13a86fccf1955d570f96e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an intptr_t value from the current location, (and update the current location to just past this intptr_t).  <a href="#a1c32b7278d13a86fccf1955d570f96e7">More...</a><br /></td></tr>
<tr class="separator:a1c32b7278d13a86fccf1955d570f96e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877bff406fcdb57676c287a78e69f74a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="blob_8h.html#a877bff406fcdb57676c287a78e69f74a">blob_read_string</a> (struct <a class="el" href="structblob__reader.html">blob_reader</a> *<a class="el" href="structblob.html">blob</a>)</td></tr>
<tr class="memdesc:a877bff406fcdb57676c287a78e69f74a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a NULL-terminated string from the current location, (and update the current location to just past this string).  <a href="#a877bff406fcdb57676c287a78e69f74a">More...</a><br /></td></tr>
<tr class="separator:a877bff406fcdb57676c287a78e69f74a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0efddf61bdfca4f2ea76759f0bec9938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efddf61bdfca4f2ea76759f0bec9938">&sect;&nbsp;</a></span>blob_copy_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blob_copy_bytes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob__reader.html">blob_reader</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read some unstructured, fixed-size data from the current location, copying it to  (and update the current location to just past this data) </p>

<p>References <a class="el" href="blob_8c.html#a9885922f129ad8afc10e24d306d79d75">blob_read_bytes()</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, <a class="el" href="shader__cache_8cpp.html#abd00e0cb0529ef8bea3b44094fa5d26d">create_linked_shader_and_program()</a>, <a class="el" href="shader__cache_8cpp.html#afae53e57fcc3e8599aa1e3b254717396">read_atomic_buffers()</a>, <a class="el" href="shader__cache_8cpp.html#a3aa5b638a7614617652e7d133de37d48">read_program_resource_data()</a>, <a class="el" href="shader__cache_8cpp.html#ab6b711062d144ab24dff202a90f79440">read_program_resource_list()</a>, <a class="el" href="shader__cache_8cpp.html#ac67156916498529b36e47b83d8b3321f">read_shader_metadata()</a>, <a class="el" href="shader__cache_8cpp.html#adba87f7d9fd6327cea752c3833caceff">read_shader_parameters()</a>, <a class="el" href="shader__cache_8cpp.html#a8669cfebb0fe452500cdcf158941c4b1">read_uniforms()</a>, and <a class="el" href="shader__cache_8cpp.html#a4566ddd42eedb6d83df0f1289e327fa1">read_xfb()</a>.</p>

</div>
</div>
<a id="adf49f24209b693e97e04e4e710da5e10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf49f24209b693e97e04e4e710da5e10">&sect;&nbsp;</a></span>blob_create()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="structblob.html">blob</a>* blob_create </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new, empty blob. </p>
<dl class="section return"><dt>Returns</dt><dd>The new blob, (or NULL in case of allocation failure). </dd></dl>

<p>References <a class="el" href="structblob.html#ae53eb1f3ee4ba7c3e33c0f75cd5b159e">blob::allocated</a>, <a class="el" href="structblob.html#a522e25077052803e34a4ef49ab5d6663">blob::data</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="shader__cache_8h.html#ad7cd079c2d834ae43d345b4325a1a58d">shader_cache_write_program_metadata()</a>.</p>

</div>
</div>
<a id="a9d0289d38b69eb83c4fa9542e76ac44e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0289d38b69eb83c4fa9542e76ac44e">&sect;&nbsp;</a></span>blob_destroy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void blob_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob.html">blob</a> *&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy a blob and free its memory. </p>

<p>References <a class="el" href="blob_8h.html#a0efddf61bdfca4f2ea76759f0bec9938">blob_copy_bytes()</a>, <a class="el" href="blob_8h.html#ab55011b62aa474bb6644a0dcb304af4f">blob_overwrite_bytes()</a>, <a class="el" href="blob_8h.html#a4a1072776ca723a121a6e1a7483b751e">blob_overwrite_uint32()</a>, <a class="el" href="blob_8h.html#a9885922f129ad8afc10e24d306d79d75">blob_read_bytes()</a>, <a class="el" href="blob_8h.html#a1c32b7278d13a86fccf1955d570f96e7">blob_read_intptr()</a>, <a class="el" href="blob_8h.html#a877bff406fcdb57676c287a78e69f74a">blob_read_string()</a>, <a class="el" href="blob_8h.html#a11dda238c6aff2f23a4a07272409868e">blob_read_uint32()</a>, <a class="el" href="blob_8h.html#a3b8efff7117e040c74fb7df19d3dd0c9">blob_read_uint64()</a>, <a class="el" href="blob_8h.html#aefb5f193f1f9cf1d2b5789e69b3d7f13">blob_reader_init()</a>, <a class="el" href="blob_8h.html#a259e953346c51f72cc2f3c9632463dd7">blob_reserve_bytes()</a>, <a class="el" href="blob_8h.html#ad9a5ee8f5d7ef18a165291f2e90c61ef">blob_write_bytes()</a>, <a class="el" href="blob_8h.html#ab46f90857fbe6ad55b792ea2607410fe">blob_write_intptr()</a>, <a class="el" href="blob_8h.html#ab096d8fb77c2c02ab782c53d6bd00940">blob_write_string()</a>, <a class="el" href="blob_8h.html#a7a5637884a67186930463dce643a5a16">blob_write_uint32()</a>, <a class="el" href="blob_8h.html#a3623542d5a2fa919b9cef4e63af89154">blob_write_uint64()</a>, <a class="el" href="structblob.html#a522e25077052803e34a4ef49ab5d6663">blob::data</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="shader__cache_8h.html#ad7cd079c2d834ae43d345b4325a1a58d">shader_cache_write_program_metadata()</a>.</p>

</div>
</div>
<a id="ab55011b62aa474bb6644a0dcb304af4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55011b62aa474bb6644a0dcb304af4f">&sect;&nbsp;</a></span>blob_overwrite_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool blob_overwrite_bytes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob.html">blob</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite some data previously written to the blob. </p>
<p>Writes data to an existing portion of the blob at an offset of . This data range must have previously been written to the blob by one of the blob_write_* calls.</p>
<p>For example usage, see blob_overwrite_uint32</p>
<dl class="section return"><dt>Returns</dt><dd>True unless the requested offset or offset+to_write lie outside the current blob's size. </dd></dl>

<p>References <a class="el" href="structblob.html#a522e25077052803e34a4ef49ab5d6663">blob::data</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, and <a class="el" href="blob_8h.html#a4a1072776ca723a121a6e1a7483b751e">blob_overwrite_uint32()</a>.</p>

</div>
</div>
<a id="a4a1072776ca723a121a6e1a7483b751e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1072776ca723a121a6e1a7483b751e">&sect;&nbsp;</a></span>blob_overwrite_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool blob_overwrite_uint32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob.html">blob</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overwrite a uint32_t previously written to the blob. </p>
<p>Writes a uint32_t value to an existing portion of the blob at an offset of . This data range must have previously been written to the blob by one of the blob_write_* calls.</p>
<p>The expected usage is something like the following pattern: </p><pre class="fragment"> size_t offset;

 offset = blob-&gt;size;
 blob_write_uint32 (blob, 0); // placeholder
 ... various blob write calls, writing N items ...
 blob_overwrite_uint32 (blob, offset, N);
</pre><dl class="section return"><dt>Returns</dt><dd>True unless the requested position or position+to_write lie outside the current blob's size. </dd></dl>

<p>References <a class="el" href="blob_8c.html#ab55011b62aa474bb6644a0dcb304af4f">blob_overwrite_bytes()</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, and <a class="el" href="shader__cache_8cpp.html#acee3d313fe3ae90859221130a56303fe">write_hash_table()</a>.</p>

</div>
</div>
<a id="a9885922f129ad8afc10e24d306d79d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9885922f129ad8afc10e24d306d79d75">&sect;&nbsp;</a></span>blob_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* blob_read_bytes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob__reader.html">blob_reader</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read some unstructured, fixed-size data from the current location, (and update the current location to just past this data). </p>
<dl class="section note"><dt>Note</dt><dd>The memory returned belongs to the data underlying the blob reader. The caller must copy the data in order to use it after the lifetime of the data underlying the blob reader.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The bytes read (see note above about memory lifetime). </dd></dl>

<p>References <a class="el" href="structblob__reader.html#abbaf698195cd9ac099c74ba9e85e0dda">blob_reader::current</a>, <a class="el" href="blob_8c.html#ae04b2d06cf8e2d728a885c004e22eda2">ensure_can_read()</a>, <a class="el" href="namespaceir__builder.html#aa357a25fd826a7e5723b6d9c5c76a680">ir_builder::ret()</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a0efddf61bdfca4f2ea76759f0bec9938">blob_copy_bytes()</a>, <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, <a class="el" href="shader__cache_8cpp.html#adf755325797e04a727b59436cd5c783c">decode_type_from_blob()</a>, and <a class="el" href="shader__cache_8cpp.html#a8669cfebb0fe452500cdcf158941c4b1">read_uniforms()</a>.</p>

</div>
</div>
<a id="a1c32b7278d13a86fccf1955d570f96e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c32b7278d13a86fccf1955d570f96e7">&sect;&nbsp;</a></span>blob_read_intptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">intptr_t blob_read_intptr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob__reader.html">blob_reader</a> *&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an intptr_t value from the current location, (and update the current location to just past this intptr_t). </p>
<dl class="section note"><dt>Note</dt><dd>This function will only read from an intptr_t-aligned offset from the beginning of the blob's data, so some padding bytes may be skipped.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The intptr_t read </dd></dl>

<p>References <a class="el" href="blob_8c.html#a78fb299c79e1e1322700321740669d97">align_blob_reader()</a>, <a class="el" href="structblob__reader.html#abbaf698195cd9ac099c74ba9e85e0dda">blob_reader::current</a>, <a class="el" href="blob_8c.html#ae04b2d06cf8e2d728a885c004e22eda2">ensure_can_read()</a>, <a class="el" href="namespaceir__builder.html#aa357a25fd826a7e5723b6d9c5c76a680">ir_builder::ret()</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>.</p>

</div>
</div>
<a id="a877bff406fcdb57676c287a78e69f74a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877bff406fcdb57676c287a78e69f74a">&sect;&nbsp;</a></span>blob_read_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* blob_read_string </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob__reader.html">blob_reader</a> *&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a NULL-terminated string from the current location, (and update the current location to just past this string). </p>
<dl class="section note"><dt>Note</dt><dd>The memory returned belongs to the data underlying the blob reader. The caller must copy the string in order to use the string after the lifetime of the data underlying the blob reader.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The string read (see note above about memory lifetime). However, if there is no NULL byte remaining within the blob, this function returns NULL. </dd></dl>

<p>References <a class="el" href="structblob__reader.html#abbaf698195cd9ac099c74ba9e85e0dda">blob_reader::current</a>, <a class="el" href="structblob__reader.html#a1449a61fa6d3d5c57e5b8a27e7d4db06">blob_reader::end</a>, <a class="el" href="blob_8c.html#ae04b2d06cf8e2d728a885c004e22eda2">ensure_can_read()</a>, <a class="el" href="structblob__reader.html#a3dd1908a474c828628a8ed60247cd98e">blob_reader::overrun</a>, <a class="el" href="namespaceir__builder.html#aa357a25fd826a7e5723b6d9c5c76a680">ir_builder::ret()</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, <a class="el" href="shader__cache_8cpp.html#abd00e0cb0529ef8bea3b44094fa5d26d">create_linked_shader_and_program()</a>, <a class="el" href="shader__cache_8cpp.html#adf755325797e04a727b59436cd5c783c">decode_type_from_blob()</a>, <a class="el" href="shader__cache_8cpp.html#a07f014d8d13bbc23e40ad88352344a8e">read_buffer_block()</a>, <a class="el" href="shader__cache_8cpp.html#a0cdbccd6516d98b3dc3f383ba3bbe91e">read_hash_table()</a>, <a class="el" href="shader__cache_8cpp.html#a3aa5b638a7614617652e7d133de37d48">read_program_resource_data()</a>, <a class="el" href="shader__cache_8cpp.html#adba87f7d9fd6327cea752c3833caceff">read_shader_parameters()</a>, <a class="el" href="shader__cache_8cpp.html#a120513fd68e4c4e7ee9023e0344bafc2">read_subroutines()</a>, <a class="el" href="shader__cache_8cpp.html#a8669cfebb0fe452500cdcf158941c4b1">read_uniforms()</a>, and <a class="el" href="shader__cache_8cpp.html#a4566ddd42eedb6d83df0f1289e327fa1">read_xfb()</a>.</p>

</div>
</div>
<a id="a11dda238c6aff2f23a4a07272409868e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11dda238c6aff2f23a4a07272409868e">&sect;&nbsp;</a></span>blob_read_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t blob_read_uint32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob__reader.html">blob_reader</a> *&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a uint32_t from the current location, (and update the current location to just past this uint32_t). </p>
<dl class="section note"><dt>Note</dt><dd>This function will only read from a uint32_t-aligned offset from the beginning of the blob's data, so some padding bytes may be skipped.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The uint32_t read </dd></dl>

<p>References <a class="el" href="blob_8c.html#a78fb299c79e1e1322700321740669d97">align_blob_reader()</a>, <a class="el" href="structblob__reader.html#abbaf698195cd9ac099c74ba9e85e0dda">blob_reader::current</a>, <a class="el" href="blob_8c.html#ae04b2d06cf8e2d728a885c004e22eda2">ensure_can_read()</a>, <a class="el" href="namespaceir__builder.html#aa357a25fd826a7e5723b6d9c5c76a680">ir_builder::ret()</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, <a class="el" href="shader__cache_8cpp.html#adf755325797e04a727b59436cd5c783c">decode_type_from_blob()</a>, <a class="el" href="shader__cache_8cpp.html#afae53e57fcc3e8599aa1e3b254717396">read_atomic_buffers()</a>, <a class="el" href="shader__cache_8cpp.html#a07f014d8d13bbc23e40ad88352344a8e">read_buffer_block()</a>, <a class="el" href="shader__cache_8cpp.html#a4595f16e07e9d53f3f9c347341efdbcd">read_buffer_blocks()</a>, <a class="el" href="shader__cache_8cpp.html#a0cdbccd6516d98b3dc3f383ba3bbe91e">read_hash_table()</a>, <a class="el" href="shader__cache_8cpp.html#a3aa5b638a7614617652e7d133de37d48">read_program_resource_data()</a>, <a class="el" href="shader__cache_8cpp.html#ab6b711062d144ab24dff202a90f79440">read_program_resource_list()</a>, <a class="el" href="shader__cache_8cpp.html#ac67156916498529b36e47b83d8b3321f">read_shader_metadata()</a>, <a class="el" href="shader__cache_8cpp.html#adba87f7d9fd6327cea752c3833caceff">read_shader_parameters()</a>, <a class="el" href="shader__cache_8cpp.html#a120513fd68e4c4e7ee9023e0344bafc2">read_subroutines()</a>, <a class="el" href="shader__cache_8cpp.html#a7d3d51838ad48b51671653bda599a3a6">read_uniform_remap_table_entry()</a>, <a class="el" href="shader__cache_8cpp.html#ad94ad7954b75bf03269a8e97efdff4d8">read_uniform_remap_tables()</a>, <a class="el" href="shader__cache_8cpp.html#a8669cfebb0fe452500cdcf158941c4b1">read_uniforms()</a>, <a class="el" href="shader__cache_8cpp.html#a4566ddd42eedb6d83df0f1289e327fa1">read_xfb()</a>, and <a class="el" href="shader__cache_8h.html#ae93d930c5601558a3410709c589ea918">shader_cache_read_program_metadata()</a>.</p>

</div>
</div>
<a id="a3b8efff7117e040c74fb7df19d3dd0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b8efff7117e040c74fb7df19d3dd0c9">&sect;&nbsp;</a></span>blob_read_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t blob_read_uint64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob__reader.html">blob_reader</a> *&#160;</td>
          <td class="paramname"><em>blob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a uint64_t from the current location, (and update the current location to just past this uint64_t). </p>
<dl class="section note"><dt>Note</dt><dd>This function will only read from a uint64_t-aligned offset from the beginning of the blob's data, so some padding bytes may be skipped.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The uint64_t read </dd></dl>

<p>References <a class="el" href="blob_8c.html#a78fb299c79e1e1322700321740669d97">align_blob_reader()</a>, <a class="el" href="structblob__reader.html#abbaf698195cd9ac099c74ba9e85e0dda">blob_reader::current</a>, <a class="el" href="blob_8c.html#ae04b2d06cf8e2d728a885c004e22eda2">ensure_can_read()</a>, <a class="el" href="namespaceir__builder.html#aa357a25fd826a7e5723b6d9c5c76a680">ir_builder::ret()</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, and <a class="el" href="shader__cache_8cpp.html#ac67156916498529b36e47b83d8b3321f">read_shader_metadata()</a>.</p>

</div>
</div>
<a id="aefb5f193f1f9cf1d2b5789e69b3d7f13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefb5f193f1f9cf1d2b5789e69b3d7f13">&sect;&nbsp;</a></span>blob_reader_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void blob_reader_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob__reader.html">blob_reader</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start reading a blob, (initializing the contents of  for reading). </p>
<p>After this call, the caller can use the various blob_read_* functions to read elements from the data array.</p>
<p>For all of the blob_read_* functions, if there is insufficient data remaining, the functions will do nothing, (perhaps returning default values such as 0). The caller can detect this by noting that the <a class="el" href="structblob__reader.html">blob_reader</a>'s current value is unchanged before and after the call. </p>

<p>References <a class="el" href="structblob__reader.html#abbaf698195cd9ac099c74ba9e85e0dda">blob_reader::current</a>, <a class="el" href="structblob.html#a522e25077052803e34a4ef49ab5d6663">blob::data</a>, <a class="el" href="structblob__reader.html#a3df1b302162487951b4209abdecddaf8">blob_reader::data</a>, <a class="el" href="structblob__reader.html#a1449a61fa6d3d5c57e5b8a27e7d4db06">blob_reader::end</a>, <a class="el" href="structblob__reader.html#a3dd1908a474c828628a8ed60247cd98e">blob_reader::overrun</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, and <a class="el" href="shader__cache_8h.html#ae93d930c5601558a3410709c589ea918">shader_cache_read_program_metadata()</a>.</p>

</div>
</div>
<a id="a259e953346c51f72cc2f3c9632463dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a259e953346c51f72cc2f3c9632463dd7">&sect;&nbsp;</a></span>blob_reserve_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t* blob_reserve_bytes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob.html">blob</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reserve space in  for a number of bytes. </p>
<p>Space will be allocated within the blob for these byes, but the bytes will be left uninitialized. The caller is expected to use the return value to write directly (and immediately) to these bytes.</p>
<dl class="section note"><dt>Note</dt><dd>The return value is valid immediately upon return, but can be invalidated by any other call to a blob function. So the caller should call blob_reserve_byes immediately before writing through the returned pointer.</dd></dl>
<p>This function is intended to be used when interfacing with an existing API that is not aware of the blob API, (so that blob_write_bytes cannot be called).</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to space allocated within  to which  bytes can be written, (or NULL in case of any allocation error). </dd></dl>

<p>References <a class="el" href="structblob.html#a522e25077052803e34a4ef49ab5d6663">blob::data</a>, <a class="el" href="blob_8c.html#a9c0415a6a5d09ff0814f0b3e494f96de">grow_to_fit()</a>, <a class="el" href="namespaceir__builder.html#aa357a25fd826a7e5723b6d9c5c76a680">ir_builder::ret()</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>.</p>

</div>
</div>
<a id="ad9a5ee8f5d7ef18a165291f2e90c61ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a5ee8f5d7ef18a165291f2e90c61ef">&sect;&nbsp;</a></span>blob_write_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool blob_write_bytes </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob.html">blob</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_write</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add some unstructured, fixed-size data to a blob. </p>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

<p>References <a class="el" href="structblob.html#a522e25077052803e34a4ef49ab5d6663">blob::data</a>, <a class="el" href="blob_8c.html#a9c0415a6a5d09ff0814f0b3e494f96de">grow_to_fit()</a>, and <a class="el" href="structblob.html#ad187cfb394fd3291ef3a942faed608ff">blob::size</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, <a class="el" href="blob_8h.html#ab46f90857fbe6ad55b792ea2607410fe">blob_write_intptr()</a>, <a class="el" href="blob_8h.html#ab096d8fb77c2c02ab782c53d6bd00940">blob_write_string()</a>, <a class="el" href="blob_8h.html#a7a5637884a67186930463dce643a5a16">blob_write_uint32()</a>, <a class="el" href="blob_8h.html#a3623542d5a2fa919b9cef4e63af89154">blob_write_uint64()</a>, <a class="el" href="shader__cache_8cpp.html#ab7d8688bec25963d61a9a89248331a90">encode_type_to_blob()</a>, <a class="el" href="shader__cache_8h.html#ad7cd079c2d834ae43d345b4325a1a58d">shader_cache_write_program_metadata()</a>, <a class="el" href="shader__cache_8cpp.html#a688ca3dd36654d06513893a8b098c3cb">write_atomic_buffers()</a>, <a class="el" href="shader__cache_8cpp.html#a08cc64d8aaa4d08b2d8e0d23c8bcb7f1">write_program_resource_data()</a>, <a class="el" href="shader__cache_8cpp.html#a474c7b502bfada56c393f47678441e68">write_program_resource_list()</a>, <a class="el" href="shader__cache_8cpp.html#a0b2f905bde7f740f14ccfbb1ab3de763">write_shader_metadata()</a>, <a class="el" href="shader__cache_8cpp.html#a8c9deee010fb00132158a1b1f6d1b1e7">write_shader_parameters()</a>, <a class="el" href="shader__cache_8cpp.html#a5251d0850705066fcc46a46a5ac7312b">write_uniforms()</a>, and <a class="el" href="shader__cache_8cpp.html#a9e1ad2054e3625d2b0c426aa6cbc61c4">write_xfb()</a>.</p>

</div>
</div>
<a id="ab46f90857fbe6ad55b792ea2607410fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46f90857fbe6ad55b792ea2607410fe">&sect;&nbsp;</a></span>blob_write_intptr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool blob_write_intptr </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob.html">blob</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">intptr_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an intptr_t to a blob. </p>
<dl class="section note"><dt>Note</dt><dd>This function will only write to an intptr_t-aligned offset from the beginning of the blob's data, so some padding bytes may be added to the blob if this write follows some unaligned write (such as blob_write_string).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

<p>References <a class="el" href="blob_8c.html#a8ad5e3b9ea1cc48d269fcea26e80cff6">align_blob()</a>, and <a class="el" href="blob_8c.html#ad9a5ee8f5d7ef18a165291f2e90c61ef">blob_write_bytes()</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>.</p>

</div>
</div>
<a id="ab096d8fb77c2c02ab782c53d6bd00940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab096d8fb77c2c02ab782c53d6bd00940">&sect;&nbsp;</a></span>blob_write_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool blob_write_string </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob.html">blob</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a NULL-terminated string to a blob, (including the NULL terminator). </p>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

<p>References <a class="el" href="blob_8c.html#ad9a5ee8f5d7ef18a165291f2e90c61ef">blob_write_bytes()</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, <a class="el" href="shader__cache_8cpp.html#ab7d8688bec25963d61a9a89248331a90">encode_type_to_blob()</a>, <a class="el" href="shader__cache_8h.html#ad7cd079c2d834ae43d345b4325a1a58d">shader_cache_write_program_metadata()</a>, <a class="el" href="shader__cache_8cpp.html#afe8dae02af1a3cbb1efd90325efc5227">write_buffer_block()</a>, <a class="el" href="shader__cache_8cpp.html#aba7f80683c89a7c87981a50ac0884d8e">write_hash_table_entry()</a>, <a class="el" href="shader__cache_8cpp.html#a08cc64d8aaa4d08b2d8e0d23c8bcb7f1">write_program_resource_data()</a>, <a class="el" href="shader__cache_8cpp.html#a8c9deee010fb00132158a1b1f6d1b1e7">write_shader_parameters()</a>, <a class="el" href="shader__cache_8cpp.html#ac1119141545d663a8e2024249de1cbbe">write_subroutines()</a>, <a class="el" href="shader__cache_8cpp.html#a5251d0850705066fcc46a46a5ac7312b">write_uniforms()</a>, and <a class="el" href="shader__cache_8cpp.html#a9e1ad2054e3625d2b0c426aa6cbc61c4">write_xfb()</a>.</p>

</div>
</div>
<a id="a7a5637884a67186930463dce643a5a16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5637884a67186930463dce643a5a16">&sect;&nbsp;</a></span>blob_write_uint32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool blob_write_uint32 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob.html">blob</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a uint32_t to a blob. </p>
<dl class="section note"><dt>Note</dt><dd>This function will only write to a uint32_t-aligned offset from the beginning of the blob's data, so some padding bytes may be added to the blob if this write follows some unaligned write (such as blob_write_string).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

<p>References <a class="el" href="blob_8c.html#a8ad5e3b9ea1cc48d269fcea26e80cff6">align_blob()</a>, and <a class="el" href="blob_8c.html#ad9a5ee8f5d7ef18a165291f2e90c61ef">blob_write_bytes()</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, <a class="el" href="shader__cache_8cpp.html#ab7d8688bec25963d61a9a89248331a90">encode_type_to_blob()</a>, <a class="el" href="shader__cache_8h.html#ad7cd079c2d834ae43d345b4325a1a58d">shader_cache_write_program_metadata()</a>, <a class="el" href="shader__cache_8cpp.html#a688ca3dd36654d06513893a8b098c3cb">write_atomic_buffers()</a>, <a class="el" href="shader__cache_8cpp.html#afe8dae02af1a3cbb1efd90325efc5227">write_buffer_block()</a>, <a class="el" href="shader__cache_8cpp.html#a2410dcfee0299064dc7d39591210c65b">write_buffer_blocks()</a>, <a class="el" href="shader__cache_8cpp.html#acee3d313fe3ae90859221130a56303fe">write_hash_table()</a>, <a class="el" href="shader__cache_8cpp.html#aba7f80683c89a7c87981a50ac0884d8e">write_hash_table_entry()</a>, <a class="el" href="shader__cache_8cpp.html#a08cc64d8aaa4d08b2d8e0d23c8bcb7f1">write_program_resource_data()</a>, <a class="el" href="shader__cache_8cpp.html#a474c7b502bfada56c393f47678441e68">write_program_resource_list()</a>, <a class="el" href="shader__cache_8cpp.html#a0b2f905bde7f740f14ccfbb1ab3de763">write_shader_metadata()</a>, <a class="el" href="shader__cache_8cpp.html#a8c9deee010fb00132158a1b1f6d1b1e7">write_shader_parameters()</a>, <a class="el" href="shader__cache_8cpp.html#a4dc059c8db22d74de4c4fdbcfb6b1f3e">write_shader_subroutine_index()</a>, <a class="el" href="shader__cache_8cpp.html#ac1119141545d663a8e2024249de1cbbe">write_subroutines()</a>, <a class="el" href="shader__cache_8cpp.html#abcb48027c2fe53fc0270fdff9ad3b88d">write_uniform_remap_table_entry()</a>, <a class="el" href="shader__cache_8cpp.html#ae9d15e94397c8fb416c93c72d37fe38a">write_uniform_remap_tables()</a>, <a class="el" href="shader__cache_8cpp.html#a5251d0850705066fcc46a46a5ac7312b">write_uniforms()</a>, and <a class="el" href="shader__cache_8cpp.html#a9e1ad2054e3625d2b0c426aa6cbc61c4">write_xfb()</a>.</p>

</div>
</div>
<a id="a3623542d5a2fa919b9cef4e63af89154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3623542d5a2fa919b9cef4e63af89154">&sect;&nbsp;</a></span>blob_write_uint64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool blob_write_uint64 </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structblob.html">blob</a> *&#160;</td>
          <td class="paramname"><em>blob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a uint64_t to a blob. </p>
<dl class="section note"><dt>Note</dt><dd>This function will only write to a uint64_t-aligned offset from the beginning of the blob's data, so some padding bytes may be added to the blob if this write follows some unaligned write (such as blob_write_string).</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>True unless allocation failed. </dd></dl>

<p>References <a class="el" href="blob_8c.html#a8ad5e3b9ea1cc48d269fcea26e80cff6">align_blob()</a>, and <a class="el" href="blob_8c.html#ad9a5ee8f5d7ef18a165291f2e90c61ef">blob_write_bytes()</a>.</p>

<p>Referenced by <a class="el" href="blob_8h.html#a9d0289d38b69eb83c4fa9542e76ac44e">blob_destroy()</a>, and <a class="el" href="shader__cache_8cpp.html#a0b2f905bde7f740f14ccfbb1ab3de763">write_shader_metadata()</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.12
</small></address>
</body>
</html>
